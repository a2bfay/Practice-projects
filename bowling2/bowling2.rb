# 13 Oct. --> KEEPING ALTERNATE OBJECT DEFINITIONS; manual merge back to main file

# BOWLING SIMULATOR WITH SCORING DONE FRAME-BY-FRAME (vs. 'kata' version)
  # crux of trouble so far:  a LANE_GAME is built out of turns, but a PLAYER_GAME is built out of consecutive frames, w/ scores
  # should frame data get stored in PLAYER?  that would require TURN to distribute FRAMES among PLAYERS

# ---- MESSAGES ----
# who's playing?
# what frame are we in?
# whose turn is it?
# what roll result/frame result? --> how good is player?
# what's the current score? --> who's the current leader?
# is the game over?
# who won?

# Getting rid of : RollCalc / Frame / Player / Turn / Game
# In favor of : Player / Frame / PlayerGame / ScoringWindow / Game
  
# ================================================================================
# METZ:
# "The knowledge that rims are at [0] should not be duplicated; it should be known in just one place."
# "these few lines of code are a minor inconvenience compared to the permanent cost of repeatedly indexing into a complex array"
# "If you rephrase every one of [a class's] methods as a question, asking the question ought to make sense."
# "Gear no longer cares about the class of the injected object, it merely expects that it implement diameter." [see 'results']
puts; puts


# ---------------------------------------------------------
# returns up to two weighted random rolls from 10 initial pins
# data: skill / behavior: rolls generated according to skill
class Player
  attr_reader :skill            # calculation methods can be invisible; skill would be useful for screen output 
  def initialize(skill = 0)
    raise RangeError unless skill >= 0
    @skill = skill
  end
    
  def roll
    reset_lane
    weighted_roll(@pins_standing)
    @results
  end
  
  private  
  
  def reset_lane
    @roll_no = 1
    @pins_standing = 10
    @results = []
  end

  def update_lane(pins_hit)
    @roll_no += 1
    @pins_standing -= pins_hit
  end
  
  def weighted_roll(pins)
    pins_hit = apply_skill(pins)
    @results << pins_hit
    update_lane(pins_hit)
    weighted_roll(@pins_standing) unless pins_hit == 10 || @roll_no > 2
  end
  
  def apply_skill(pins)
    picks = []
    (@skill + 1).times { picks << rand(0..pins)
                         break if picks.max == pins }
    picks.max
  end
end


# ---------------------------------------------------------
# initialize with array generated by Player
# stores/evaluates set of rolls in single array
# data: rolls / behavior: totals and checks for bonus
class Frame
  attr_reader :results             # read only; avoid accessor 
  def initialize(player_roll)
    @results = player_roll         # not really an injection - simply initialize with array
  end                              
  
  def first_roll
    @results[0]
  end
  
  def second_roll
    @results[1]                                                   # doesn't require an 'unless' -- simply returns nil if nothing there
  end
  
  def total
    @results.reduce(:+)  
  end                    

  def strike?
    @results[0] == 10
  end
  
  def spare?
    strike? == false && total == 10
  end
end


# ---------------------------------------------------------
# \\ sure about below? //  that basically means passing player all down the chain...
# initialize with Player, not with skill setting; for now, knows that Player can .roll --> makes Frame better to test
# generates and stores set of Frame objects in new array
# data: player, frames, turn scores / behavior: generates new frames, (eventually) passes to scoring process
class PlayerGame
  attr_reader :player, :frames, :scores
  def initialize(player) 
    @player = player
    @frames = []
    @scores = []    # this can just be array of numbers --> not array of arrays
  end
  
  def take_turn
    # puts "\nPG#{__LINE__} - @frames.length - #{@frames.length}"
    @frames.length == 9  ?  bowl_tenth  :  bowl
    score_turn
  end

  def frames_played
    @frames.map { |fr| fr.results }
  end
  
  # could be private, except for tests
  def last_known_score
    # puts "compact #{@scores.compact}"
    # puts "nil? #{@scores.compact.nil?}"
    # puts "empty? #{scores.compact.empty?}"
    @scores.compact.empty?  ?  0  :  @scores.compact[-1]
  end
  
  private
  
  def bowl
    player_frame = Frame.new (@player.roll)     # pass Frame object into variable, not Frame.results
    @frames << player_frame                     # do the same here? --> YES. makes Frame methods available elsewhere
  end

  def bowl_tenth
    base_frame = Frame.new (@player.roll)
    if base_frame.strike? || base_frame.spare?
      # puts base_frame.results.inspect                                
      first_bonus  = Frame.new (@player.roll)
      second_bonus = Frame.new (@player.roll)
      source_rolls = [base_frame.results, first_bonus.results, second_bonus.results]
      three_rolls  = source_rolls.flatten.shift(3)
      tenth_frame  = Frame.new (three_rolls)
      @frames << tenth_frame
    else
      @frames << base_frame
    end
  end
  
  def current_frame
    @frames.length
  end

  def score_turn
    active_frames = (current_frame <= 3)  ?  @frames  :  @frames[-3..-1]
      # puts "*** #{active_frames} ***"
    window = ScoringWindow.new( active_frames, last_known_score )
    @scores << window.return_scores[-1]           # no if -- this will always come back
    @scores[-2] ||= window.return_scores[-2] if window.return_scores.length >= 2
    @scores[-3] ||= window.return_scores[-3] if window.return_scores.length == 3                 # <= need to set these up next
      # puts "\tlast_scored #{last_frame_scored}"       # temp for testing
  end
  
  # def last_frame_scored
      # # puts "l_f_s #{@scores.flatten}"
    # @scores.flatten.compact.length
  # end
 
  # def frame(num)
    # @frames[num - 1]
  # end

  # def frame_results(num)
    # frame(num).results
  # end
  
end


# needs to know methods from Frame, unless get rid of that class
class ScoringWindow
  attr_reader :return_scores
  def initialize( frames, base_score )
    raise RangeError unless base_score >= 0
    @frames = frames
    @base_score = base_score                                   # which frame this corresponds to is variable...
    @return_scores = []
      # input_frames = @frames.map { |fr| fr.results }                                # temp for testing
      # puts "\nwindow\t\t    base = #{@base_score}\n\t#{input_frames.inspect}\n\n"
    calculate_scores
      # puts "\n\t#{@return_scores.inspect}"                                          #temp for testing
  end

  private
  
  def two_prev
    @frames[-3]
  end
  
  def one_prev
    @frames[-2]
  end
  
  def current
    @frames[-1]
  end
  
  def tenth_bonus?
    current.results.length == 3
  end
    
  def calculate_scores
    update_two_prev
    tenth_bonus?  ?  ( update_ninth_before_bonus; score_tenth_bonus )
                  :  ( update_one_prev; score_current )
  end
      
  def update_score(amount)
    # puts "\tu_s #{__LINE__}"
    @base_score += amount
    # puts "\tu_s #{__LINE__}\tnew base = #{@base_score}"
    @return_scores << @base_score
  end
  
  def update_two_prev
    # puts "\tu2p #{__LINE__}"
    return if two_prev.nil?
    # puts "\tu2p #{__LINE__} - past nil check"
    return unless ( two_prev.strike? && one_prev.strike? )
    # puts "\tu2p #{__LINE__} - past strike_s_ check"
    frame_rolls = @frames.map { |fr| fr.results }    
    flat_rolls = frame_rolls.flatten
    bonus = flat_rolls[1] + flat_rolls[2]
    update_score(10 + bonus)
  end
      
  def update_one_prev
    # puts "\tu1p #{__LINE__}"
    return if one_prev.nil?
    # puts "\tu1p #{__LINE__} - past nil check"
    return unless ( one_prev.strike? || one_prev.spare? )
    # puts "\tu1p #{__LINE__} - past bonus check"
    if ( one_prev.strike? && current.strike? )                                      # no, not return -- this needs to append nil
      @return_scores << nil
      # puts "\tu1p #{__LINE__} - append nil"
    else
      # puts "\tu1p #{__LINE__} - past current strike check"
      bonus = one_prev.strike?  ?  current.total  :  current.first_roll
      # puts "\tu1p #{__LINE__} - sending #{bonus} bonus"
      update_score(10 + bonus)
    end  
  end

  def score_current
    # puts "\ts_c #{__LINE__}"
    if current.strike? || current.spare?
      @return_scores << nil
      # puts "\ts_c #{__LINE__} - append nil"
    else
      # puts "\ts_c #{__LINE__} - to u_s"
      update_score(current.total)
    end      
  end
  
  def update_ninth_before_bonus
    # puts "\tu9b #{__LINE__}"
    return unless ( one_prev.strike? || one_prev.spare? )
    # puts "\tu9b #{__LINE__} - past bonus check"
    bonus = one_prev.strike?  ? (current.first_roll + current.second_roll)  
                              :  current.first_roll
    update_score(10 + bonus)
  end
  
  def score_tenth_bonus
    # puts "\tu10 #{__LINE__}"
    update_score(current.total)
  end
end


# initialize with array of Players
class Game
  attr_reader :players, :player_games # :winner 
  def initialize(players)
    @players = players
    @player_games = []
    @players.each { |player| @player_games << PlayerGame.new(player) }
    # puts "\ninside class: #{@player_games.length}" # temp
    play_game
  end
  
  private
  
  def play_game
    10.times { play_turn }
  end
  
  def play_turn
    @player_games.each { |curr_player| curr_player.take_turn }
  end
end


class TempOutputTests
  # have to be combined - separate methods loses player creation...
  def base_output_tests
    player1 = Player.new
    puts player1.skill
    puts player1.roll.inspect
    puts 

    player2 = Player.new 15
    puts player2.skill
    puts player2.roll.inspect
    puts

    frame1 = Frame.new (player1)
    puts "frame1:\t#{frame1.results}"
    
    pgame1 = PlayerGame.new (player1)
    3.times { pgame1.take_turn }
    puts "pgame1:\t#{pgame1.frames_played}"

    pgame2 = PlayerGame.new (player2)
    3.times { pgame2.take_turn }
    puts "pgame2:\t#{pgame2.frames_played}"
    puts pgame2.last_known_score
  end
  
  def output_test_game
    input_players = [Player.new, Player.new(2), Player.new(4), Player.new(8)]
    (0...input_players.length).each { |i| puts "Player #{i + 1} / #{input_players[i].skill}" }
    game1 = Game.new (input_players)
    # puts game1.inspect
    puts
    (0...input_players.length).each do |i|
      puts game1.player_games[i].frames_played.inspect
      puts game1.player_games[i].last_known_score
    end
  end
end


# user input here --> gets skill and creates player array
def input_player_settings
  print "How many players(1-4)?  "
    numplayers = gets.chomp.to_i
    numplayers = 1 if numplayers < 1
    numplayers = 4 if numplayers > 4
  
  @input_players = []
  puts "Enter skill level 0-15 (2+ = good, 4+ = v.good, 6+ = pro):"
  (1..numplayers).each do |p|
    print "Skill level for player #{p}?  "
    skill = gets.chomp.to_i
    skill = 0 if skill < 0
    @input_players << Player.new(skill)
  end
end

def single_game
  input_player_settings
  game = Game.new(@input_players)
  (0...@input_players.length).each do |i|  
    puts
    (0...10).each do |fr|
      print game.player_games[i].scores[fr].inspect, "\t"
      print game.player_games[i].frames[fr].results.inspect, "\n"
    end
  end
                                     
end
 single_game








# ===================================================================================================================================================================
# METZ "test everything just once and in the proper place"
# "This choice between injecting real or fake objects has far-reaching consequences.
# Injecting the same objects at test time as are used at runtime ensures that tests break
# correctly but may lead to long running tests. Alternatively, injecting doubles can speed
# tests but leave them vulnerable to constructing a fantasy world where tests work but
# the application fails."

require "test/unit"
puts "\n ------- TESTS -------"

class TestPlayer < Test::Unit::TestCase
  def test_roll_limits
    player = Player.new
    assert player.roll.max <= 10
    assert player.roll.min >= 0
  end
  
  def test_roll_sum
    player = Player.new
    assert player.roll.reduce(:+).between? 0, 10
  end
    
  def test_roll_sum_skill
    player = Player.new 15
    assert player.roll.reduce(:+).between? 0, 10
  end
end


# Frame only knows that the object passed to it responds to results
class TestFrame < Test::Unit::TestCase
  def test_first_roll
    frame = Frame.new [3,4]
    assert frame.first_roll == 3
  end
  
  def test_second_roll
    frame = Frame.new [3,4]
    assert frame.second_roll == 4
  end
      
  def test_frame_total
    frame = Frame.new [3,4]
    assert frame.total == 7
  end
  
  def test_second_roll_nil
    frame = Frame.new [10]
    assert frame.second_roll.nil?
  end
  
  def test_frame_strike
    frame = Frame.new [10]
    assert frame.strike?      
  end 
  
  def test_frame_spare
    frame = Frame.new [2,8]
    assert frame.spare?
  end
end


# seems tough to test - game logic is here, with non-deterministic results,
#   and all classes except Game 
# since overall program is small, creating actual objects instead of mocks
class TestPlayerGame < Test::Unit::TestCase
  def test_take_turn_appends_to_frames_array
    playergame = PlayerGame.new(Player.new)
    playergame.take_turn
    assert playergame.frames.length == 1
  end
  
  def test_take_turn_appends_to_scores_array
    playergame = PlayerGame.new(Player.new)
    playergame.take_turn
    assert playergame.scores.length == 1
  end
  
  def test_last_known_score_never_nil
    playergame = PlayerGame.new(Player.new)
    assert_not_nil playergame.last_known_score
    playergame.take_turn
    assert_not_nil playergame.last_known_score
  end
  
  def test_frames_played_extracts_numeric_values_only
     playergame = PlayerGame.new(Player.new)
     playergame.take_turn
     assert playergame.respond_to?(:max) == false
     assert playergame.frames_played.respond_to?(:max) == true
  end
end


class TestScoringWindow < Test::Unit::TestCase
  def setup
    @open_frame = Frame.new( [3, 4] )
    @strike = Frame.new( [10] )
    @spare = Frame.new( [2,8] )
    @bonus_tenth = Frame.new( [8, 2, 10] )
  end
  
  def test_open_frames_return_newest_only
    window = ScoringWindow.new( [@open_frame, @open_frame, @open_frame], 14 )
    assert window.return_scores == [21]
  end
  
  def test_spare_frames_return_one_update_plus_nil
    window = ScoringWindow.new( [@spare, @spare, @spare], 12 )
    assert window.return_scores.length == 2
    assert window.return_scores == [24, nil]
  end
  
  def test_strike_frames_return_one_update_plus_two_nils
    window = ScoringWindow.new( [@strike, @strike, @strike], 0 )
    assert window.return_scores == [30, nil, nil]
  end
  
  def test_strikes_then_open_return_two_updates_plus_newest
    window = ScoringWindow.new( [@strike, @strike, @open_frame], 0 )
    assert window.return_scores == [23, 40, 47]
  end
    
  def test_bonus_tenth_scored_correctly
    window = ScoringWindow.new( [@strike, @strike, @bonus_tenth], 0 )
    assert window.return_scores == [28, 48, 68]
  end
end


# GameTurn uses only one interface (take_turn), but it's a command
#   -- the data in each Player changes when it gets that message
# as above w/ PG: testing w/ actual objects instead of mocks because overall program is small
class TestGame < Test::Unit::TestCase
  def test_single_game_generates_ten_frames
    game = Game.new [Player.new]
      # puts "\nsingle >> #{game.player_games.inspect}"
      # puts "\n << #{game.player_games.length} >>"
    assert game.player_games.length == 1
      # puts game.player_games[0].frames_played.inspect
    assert game.player_games[0].frames_played.length == 10    
  end
  
  def test_single_game_generates_valid_score
    game = Game.new [Player.new]
    total = game.player_games[0].scores[-1]
    assert total.between? 0, 300    
  end
  
  def test_multplr_game
    mpl_game = Game.new [Player.new, Player.new, Player.new, Player.new]
      # puts "\nmult >> #{mpl_game.player_games.inspect}"
      # puts "\n << #{mpl_game.player_games.length} >>"
    assert mpl_game.player_games.length == 4
      # puts "\nmult >>> #{mpl_game.player_games[0].frames_played.inspect}"
      # puts "\n << #{mpl_game.player_games[3].frames_played.length} >>"
    assert mpl_game.player_games[3].frames_played.length == 10 
  end  
end



















# # =========================================================================================================
# # TEMP TESTS / OUTPUT GUIDES

# # for understanding structure of object
# def roll_tests_temp
  # puts "roll_tests line #{__LINE__}"
  # roll1 = RollCalc.new
  # puts "this is object: #{roll1}"
  # puts "this is reading result w/in object: #{roll1.results} / no change between readings: #{roll1.results}"
  # roll2 = RollCalc.new.results
  # puts "this is result of new object saved to var: #{roll2}"
  # puts
# end
# # roll_tests_temp

# def temp_roll_output_test 
  # test_rollcalc = RollCalc.new
  # puts "test_rollcalc: #{test_rollcalc}"
  # puts "test_rollcalc.results: #{test_rollcalc.results}"
  # puts
# end
# # temp_roll_output_test

# # guide to screen output from Frame when initialized with RollCalc OBJECT - not just results
# def temp_frame_tests_NEW
  # 2.times do
    # puts "Frame Skill 0"
    # test_fr = Frame.new ( RollCalc.new ) # here i'm passing in the OBJECT
    # puts test_fr.inspect
    # puts test_fr.results.inspect
    # puts test_fr.first_roll
    # puts test_fr.second_roll           # no error w/ strike, just blank
    # puts test_fr.second_roll.inspect   # yes, nil in that case
    # puts test_fr.total
    # puts test_fr.strike?
    # puts test_fr.spare?
    # puts
  # end

  # 2.times do
    # puts "Frame Skill 15"
    # test_fr = Frame.new ( RollCalc.new(15) )
    # puts test_fr.inspect
    # puts test_fr.results.inspect
    # puts test_fr.first_roll
    # puts test_fr.second_roll           # no error w/ strike, just blank
    # puts test_fr.second_roll.inspect   # yes, nil in that case
    # puts test_fr.total
    # puts test_fr.strike?
    # puts test_fr.spare?
    # puts
  # end
# end
# # temp_frame_tests_NEW

# # guide to screen output when player's @frames is an array of Frame *objects* (not just result arrays)
# def player_tests_temp
  # you = Player.new
  # me = Player.new 5
  # 3.times { you.take_turn; puts you.frames.inspect }   # can't simply drop frames.results.inspect in here
  # 3.times { me.take_turn; puts me.frames.inspect }
  # puts
  # # +1's below only because using single iterator (might otherwise be array index vs. frame no)
  # (0..2).each do |i| 
    # puts "*"
    # puts me.frames[i].inspect             # v
    # puts me.frame(i + 1)                  # this and above are almost equivalent (this line doesn't include @results
    # puts me.frames[i].results.inspect     # this and both below are exactly equivalent
    # puts me.frame(i + 1).results.inspect  # ^
    # puts me.frame_results(i + 1).inspect  # ^
    # puts me.frames[i].strike?
    # puts me.frames[i].spare?
    # puts "*"
    # puts " #{me.frames_played}"
    # puts me.frames_played                 # ok, funny: top line works just like .inspect; bottom spreads all entries on sep lines
  # end
# end
# # player_tests_temp  

# # checking execution of GameTurn by itself and as called by Game; screen outputs included
# # works for game initialized with Player objects - numplayers from UI
# def game_tests_temp
  # puts "turns"
  # alpha = Player.new
  # beta = Player.new
  # 10.times do 
    # turn = GameTurn.new [alpha, beta]
    # puts alpha.frames_played.inspect, beta.frames_played.inspect; puts
  # end

  # puts "test game"
  # input_players = []
  # (0..3).each { |skill| input_players << Player.new(skill) }
  # test_game = Game.new input_players          # this should be fixed
  # test_game.play_game
  # players = test_game.players
  # players.each { |player| puts player.frames_played.inspect }
  # puts
# end
# # game_tests_temp
